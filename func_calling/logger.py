"""
logger.py is used to record the logs of the assistant and user messages.
And record the logs of the tools used and code generated by the assistant.
"""

import json
import logging
import os.path
from pathlib import Path
from typing import Union, Optional
import re


def _extract_code(response: str) -> list[dict]:
    pattern = r"```(python|bash)\n(.*?)\n```"
    code = []
    for match in re.finditer(pattern, response, re.DOTALL):
        code.append({"language": match.group(1), "code": match.group(2)})
    return code


class Logger:
    def __init__(self, log_file, logger):
        self.log_file = Path(log_file)
        self.logdir = self.log_file.parent
        self.logdir.mkdir(parents=True, exist_ok=True)
        self.logger = logger
        self.assistant = []
        self.user = []
        self.analysis = []
        self.tools = []
        self.code = []
        self.exception = []
        self.finish_reason = "unknown"

    def log(self, message: str):
        if self.logger:
            self.logger.log(level=logging.DEBUG, msg=message)
        self.log_file.open("a").writelines(message)

    def user_message(self, message: str):
        self.user.append({"message": message})

    def assistant_message(self, rounds: int, message: str):
        self.assistant.append({"rounds": rounds, "message": message})
        if _extract_code(message):
            self._code_generated(rounds, message)
        else:
            self.analysis.append({"rounds": rounds, "message": message})

    def tool_used(self, rounds: int,
                  tool_result: Optional[list[dict]] = None):
        self.tools.append({"rounds": rounds, "tool_result": tool_result})

    def _code_generated(self, rounds: int, response: str):
        self.code.append({"rounds": rounds, "code": _extract_code(response)})

    def finish(self, reason: str):
        self.finish_reason = reason


# class ToolWrapper:
#     def __init__(self, logger: Logger, tool: Tool):
#         self.logger = logger
#         self.tool = tool
#
#     def run(self, message):
#         self.logger.log(f"Tool: {self.tool.name}")
#         arguments = self.tool.extract_parameters(message)
#         self.logger.log(f"Arguments: {json.dumps(arguments, indent=4)}")
#         result = self.tool.run(arguments)
#         result = json.loads(result)
#         if result["error"]:
#             self.logger.log(f"Error: {json.dumps(result['error'])}")
#
#
#
#
#
class GlobalLogger:
    def __init__(self):
        self.analysis = []
        self.python_code = []
        self.bash_code = []
        self.no_code = []
        self.error_python = []
        self.error_bash = []
        self.partially_solved = []
        self.solved = []
        self.unsolved = []
        self.unknown = []
        self.exception = []

    def append_analysis(self, challenge: str):
        self.analysis.append(challenge)

    def append_python_code(self, challenge: str):
        self.python_code.append(challenge)

    def append_bash_code(self, challenge: str):
        self.bash_code.append(challenge)

    def append_no_code(self, challenge: str):
        self.no_code.append(challenge)

    def append_error_python(self, challenge: str):
        self.error_python.append(challenge)

    def append_error_bash(self, challenge: str):
        self.error_bash.append(challenge)

    def append_partially_solved(self, challenge: str):
        self.partially_solved.append(challenge)

    def append_solved(self, challenge: str):
        self.solved.append(challenge)

    def append_unsolved(self, challenge: str):
        self.unsolved.append(challenge)

    def append_unknown(self, challenge: str):
        self.unknown.append(challenge)

    def append_exception(self, challenge: str, exception: str):
        self.exception.append({challenge: exception})

    def write_to_file(self, file: Union[str, Path]):
        data = {
            "analysis": self.analysis,
            "python_code": self.python_code,
            "bash_code": self.bash_code,
            "no_code": self.no_code,
            "error_python": self.error_python,
            "error_bash": self.error_bash,
            "partially_solved": self.partially_solved,
            "solved": self.solved,
            "unsolved": self.unsolved,
            "unknown": self.unknown,
            "exception": self.exception,
        }
        if isinstance(file, str):
            file = Path(file)
        with open(os.path.abspath(file), "w") as f:
            json.dump(data, f, indent=4)
